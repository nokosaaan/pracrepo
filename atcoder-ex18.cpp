#include <bits/stdc++.h>
using namespace std;

int main() {
  int N, M;
  cin >> N >> M;
  vector<int> A(M), B(M);
  for (int i = 0; i < M; i++) {
    cin >> A.at(i) >> B.at(i);
  }

  // ここにプログラムを追記
  vector<vector<string>> vec(N,vector<string>(N,"-"));
  for(int j=0; j<M; j++){
      if(A.at(j)!=B.at(j)){
          vec.at(A.at(j)-1).at(B.at(j)-1)="o";
          vec.at(B.at(j)-1).at(A.at(j)-1)="x";
      }
  }
  for(int l=0; l<N; l++){
      for(int m=0; m<N; m++){
          cout << vec.at(l).at(m) ;
          if(m==N-1) cout << endl;
          else cout << " ";
      }
      
  }
  
}
/*感想：難しい、このへんから段々問題自体が難しく
        なっていく印象がある。追記部分からみていこう。
        まず二次元配列の書き方を覚えないといけない。
        こればっかりは慣れが必要であろう。配列の
        要素をすべて-で初期化するのだが、ここで一つ問題
        がある。-はchar型なのだが、○や×はstring型なのだ。
        困った。これでは配列の型を決められないじゃないか、
        と思ったそこのあなた。何かお忘れのようだ。
        そうだ型変換があるじゃないか！僕の場合は
        -をダブルクォーテーション(""←これのこと)
        で括ることで暗黙的に-をstring型に変換させ、
        この問題を解決した。
        次に、一個目のfor文の中身だが、これは配列との
        対応関係を考えればわかる。配列は(0,0)で定義されるが、
        問題文で与えられているのは、(1,1)が基準のものである。
        であるから、例えばA.at(j)=2でB.at(j)=3だとすると、
        二次元配列上では、(1,2)に○を、(2,1)に×を書かないと
        正しく表示されないのである。だから配列の.at()の
        中身に-1の処理を行っている。
        二個目のfor文の中身は試合結果の表を表示するだけなので
        何も問題はないと思うが、こまごまとした話をすると、
        ifとelseで要素間に空白をいれるか入れないかの処理を
        している。これは問題文中にヒントとして書いてあった
        ので、そちらを参照してもらう方がよいだろう。*/
